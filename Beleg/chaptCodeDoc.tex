
\chapter{Dokumentation}




\section{Software-Architektur}

\lipsum[1]

\begin{figure}[h!]
\begin{center}
\includegraphics[height=170pt]{cross.png}
\caption{Klassendiagramm}
\label{fig:classdiag}
\end{center}
\end{figure}
    



\section{Stages}
\label{sect:stages}


\subsection{Aufbau}

Eine Stufe besteht im Wesentlichen aus 2 Gruppen von Komponenten: den statischen, unveränderlichen und den dynamisch generierten.

\renewcommand{\imgspace}{8em}
\imgtxt{stageInspect.png}{
Zu den statischen gehören Wände, die den Spielbereich abgrenzen und ggf. Hindernisse auf dem Spielfeld darstellen, der Spawn auf dem der Spieler die Stufe betritt, das Portal durch das der Spieler in die nächste Stufe gelangt und der Charger, den der Spieler aufladen muss, um das Portal zu aktivieren. (siehe \fullref{img:stage}) \\

Zu den dynamischen (im Bild links markiert) gehören die Gegner, abgefeuerte Bullets, Collectables, ggf. dynamisch generierte Hindernisse sowie dazugehörige Partikeleffekte. Zudem kann es in einer Stufe ein oder mehrere für den Spieler unsichtbare Gegnerspawner (siehe \nameref{subsect:spawner}) geben.
}

Alle dynamischen Objekte werden in einem dafür angelegten Containerobjekt in der Stage hinterlegt, damit er in seiner Gesamtheit beim Entladen einer Stufe gelöscht werden kann.



\subsection{Tutorialstages}

Das Tutorial besteht aus geskripteten Stages mit voreingestellten Spawnern, Farbcollectables und Hinweistexten. Die Hinweistexte und manchmal auch andere Komponenten werden hierbei durch zu den Stages gehörigen Skripte gesteuert. Dabei kann es unterschiedliche Verhalten geben, wenn der Endlosmodus bereits freigeschalten wurde, bspw. für die Anzeige von Statistiken und dem Highscore im Hauptmenü.



\subsection{Stagegenerator}

\lipsum[3]



\section{Spieler}

\lipsum[3]



\subsection{Input}

\lipsum[3]


\subsection{Movement}

\lipsum[3]


\subsection{Shooting}

\lipsum[3]


\subsection{Ressource}

\lipsum[3]




\section{Gegner}

\lipsum[3]



\subsection{Context-Steering}

Um das Gefecht interessanter zu machen wurde die Gegner-KI mit dem sog. Context-Steering Algorithmus\cite{qCtxSteer} (auch gen. Behavior-Driven Steering) ausgestattet.

Grundlegend wird hierbei jedem Objekt ein Wert zugeordnet der angibt, wie anstrebenswert es von bestimmten Entitäten ist. Ein positiver Wert ist hierbei ein Ziel, welches verfolgt wird, während ein negativer Wert ein zu vermeidendes Objekt darstellt.

In dieser Implementierung gibt es sog. Effektoren, die jeweils vier Werte speichern:

\begin{description}
\item[Zieltag] Zeichenkette, die die Gruppe an Objekten mit dieser Begehrlichkeit beschreibt
\item[Begehrlichkeit] wie anstrebenswert ein Objekt ist. Ein positiver Wert ist hierbei ein Ziel, welches verfolgt wird, während ein negativer Wert ein zu vermeidendes Objekt darstellt.
\item[Mindestabstand] Wie nah eine Entität sein muss, um von diesem Effektor beeinflusst zu werden
\item[Typ] Wie stark der Effektor abhängig vom Abstand wirkt. Das kann hier entweder logisch, linear oder quadratisch sein. 
\end{description}

Jede Entität bestimmt dann anhand der Formel $ clamp(typed(1 - dist / dist_{min}), 0, 1) * v_{dir} $ einen Vektor der die die Richtung und die Kraft zu diesem Objekt angibt.

Für die Erkennung von Wänden schaut jede Entität in in 30° Schritten um sich herum und schickt in jede dieser Richtungen einen Physik-Raycast. Von den Effektor-Vektoren wird dann  mittels Punktprodukt ein anteiliger Faktor in diese Richtung ermittelt und die resultierende Richtung durch die Summe dieser Richtungsvektoren ermittelt. Für etwas mehr Abwechslung wird diese noch durch Perlin-Noise ein wenig abgeändert.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\linewidth]{ctxSteer.png}
\caption{Debug-Linien vom Kontext-Steering}
\label{img:ctxSteer}
\end{figure}

Da jede Gegnerart ein eigenes Verhalten hat, haben diese auch unterschiedliche Effektorenlisten. Strays besitzen nur das Standardverhalten und bewegen sich rein durch noise und vermeiden Wände und andere Gegner. Hunter haben zusätzlich eine Kraft zum Spieler hin und Archer wiederum noch einen Effektor mit kleinerem Radius vom Spieler weg, ebenfalls mit etwas Noise damit der Archer scheinbar vom SPieler strategisch vor- und zurückweicht.



\subsection{Gegnerspawner}
\label{subsect:spawner}

Die Gegnerspawner sind standardisierte Rechteck-Objekte, die unsichtbar für den Spieler einen Bereich markieren in dem Gegner mit einstellbaren Wahrscheinlichkeiten und Eigenschaften erscheinen:

\begin{description}
\item[Typverteilung] Wahrscheinlichkeitsverteilung der Gegnertypen.
\item[Farbverteilung] Wahrscheinlichkeitsverteilung der Farbmodifikatoren, abhängig von der Reihenfolge, in der die Schussfarben eingesammelt wurden.
\item[maxColors] maximale Anzahl an Farben die die Gegner haben können
\item[amount] maximale Anzahl an Gegner die dieser Spawner spawnt
\item[wavesize] Anzahl an Gegnern die der Spawner auf einmal spawnt (typischerweise 1-3)
\item[initDelay] Zeitspanne die der Spawner nach Aktivierung des Chargers wartet bis er anfängt Gegner zu spawnen
\item[delay] Zeitspanne zwischen Gegnerwellen
\item[variation] Zeitspanne, nach der einzelne Gegnerspawns verzögert werden
\end{description}

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{spawner.png}
\caption{Spawner im Unity-Inspektor}
\label{img:spawner}
\end{figure}

Zudem hat jede Stage eine Maximale Anzahl an Gegnern, die sich Zeitgleich in der Stage aufhalten können, damit der Spieler nicht von Gegnern überrant wird.

In jeder Stage können beliebig viele Spawner platziert werden, jedoch ist durch die verfügbaren Einstellungsmöglichkeiten schon mit einem einzelnen Spawner meist ausreichend Variabilität möglich. Mehrere Spawner werden erst vonnöten, wenn man in einer Stage zeitlich verteilt verschiedene Wellen spawnen möchte.




\section{Physik}

\lipsum[3]



\section{Sound}

\lipsum[3]



\section{Spielerdaten}

Im Spiel werden verschiedene Arten von Daten persistent in Dateien abgespeichert. Als Datenformat wurde hier der Einfachheit halber JSON verwendet, da es einfach und menschenlesbar ist, sowie eine ausgezeichnete Portabilität zwischen Programmiersprachen hat, was ggf. für eine spätere Weiterverarbeitung und Auswertung nützlich sein kann. Gespeichert werden hierbei Fortschrittsstatistiken, Einstellungen und Nutzerstatistiken.



\textbf{Fortschritt} \\
Um im Spiel einen Wettbewerbsfaktor einzubringen, werden Statistiken aufgezeichnet, mit denen man Rückschlüsse auf die Fähigkeit eines Spielers ziehen kann. Diese werden ihm nach erfolgreicher Beendigung des Tutorials im Hauptmenü angezeigt. Dazu gehören zum einen allgemeine Informationen über die Spieldauer, dem Sessionzähler und die Anzahl der verschossenen Projektile, aber auch welche die maximal erreichte Stage ist, wie viele Stages insgesamt geschafft wurden, wie viele Gegner er besiegt hat und wie oft er selbst dabei daran glauben musste.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\linewidth]{stats.png}
\caption{Statistiken im Hauptmenü}
\label{img:gameStats}
\end{figure}



\textbf{Einstellungen} \\
Weiterhin kann der Spieler im Spiel Einstellungen bezüglich Sound und Grafik vornehmen, um sein Spielerlebnis anzupassen, aber auch um die Plattformkompatibilität zu gewährleisten, da ältere Grafikkarten und vor allem integrierte Grafikeinheiten wie z. B. bei Laptops keine Compute Shader unterstützen oder allgemein zu wenig Leistung haben, um das Spiel in höchster Qualität flüssig spielen zu können. Diese sind auch als Tastaturkürzel bedienbar, sollte es zu einem Grafikfehler kommen und die GUI nicht bedienbar sein. (Z. B. öffnet die Kombination [X + M] das Einstellungsmenü)

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{config.png}
\caption{Einstellungen im Pausenmenü}
\label{img:gameConfig}
\end{figure}



\textbf{Nutzerstatistiken} \\
Au{\ss}erdem werden über die Dauer einer Spielsession Daten über den Spieler aufgezeichnet, mit denen der grobe Ablauf seines Spielerlebnisses nachvollzogen werden kann. Diese sollen später benutzt werden, um das Spiel zu verbessern (mehr dazu siehe \fullref{chapt:PlayerStats}).
Dabei wird für jede Stage die der Spieler betritt aufgezeichnet welchen Zustand der Spieler zu Beginn der Stage hatte (Leben, Schussfarben, Ressourcen), wie lang der Spieler zum Laden des Chargers gebraucht hat, wie oft Gegner eines bestimmten Typs und Farbe vorgekommen sind, welche Collectables gedroppt wurden und welche Schussfarben er benutzt hat.