
\section{Postprocessing}

Postprocessing bezeichnet im Kontext der Videospielgrafik die Nachbearbeitung eines bereits ganz oder teilweise gerenderten Bildes mit einem oder mehreren Bildeffekten. Das Ziel des Postprocessings bei Cubix ist es, alte Videoaufnahme- und -wiedergabegeräte nachzubilden. Um diesen Effekt zu erzielen, werden Bildartefakte, die durch diese Hardware entstehen, als Nachbearbeitungseffekte dem fertigen Bild hinzugefügt.

Die verwendeten Effekte, die von alten Kameras verursacht werden, sind Bloom, Lens Flare, Chromatic Aberration und Vignette. 
Ein alter Monitor kann Scanlines verursachen, gewölbt sein und ebenfalls für Vignette und Chromatic Aberration sorgen.

Jeder der genannten Effekte wird in den späteren Abschnitten genauer erläutert. Man beachte, dass sowohl alte Displays als auch Linsen Vignette und Chromatic Aberration verursachen können, was dann zu kleinen Unterschieden im Auftreten dieser Effekte führen kann. Die Entscheidung, wie diese Effekte letztendlich darzustellen sind ist rein artistisch.



\subsection{Postprocessing - Pipeline}

Das Postprocessing wird über ein ebenso benanntes Skript gesteuert. Bloom und Lens Flare werden von einem jeweils eigenen Compute Shader durchgeführt, alle anderen Effekte werden in eigenen Passes eines Image Effect Shaders durchgeführt. Diese sind im Skript als Objekte angelegt:

\begin{csh}
    public ComputeShader bloom;
    public ComputeShader lensFlare;
    public Material postProcMat;
\end{csh}

Weiterhin werden für den Lens Flare eine Textur einer schmutzigen Linse und eine Starburst Textur benötigt:

\begin{csh}
    public Texture2D lensDirtTex;
    public Texture2D starburstTex;
\end{csh}

Zur Sequenziellen Ausführung aller Effekte werden insgesamt 6 RenderTextures angelegt:

\begin{csh}
    public RenderTexture sourceTex;
    public RenderTexture brightTex;
    public RenderTexture blurrBuff;
    public RenderTexture caResult;
    public RenderTexture lfResult;
    public RenderTexture lensDirt;
\end{csh}

Zum Start des Programms oder falls die Fenstergrö{\ss}e geändert wird, müssen alle diese RenderTextures nmit der Funktion createTexture() neu angelegt werden.

Durchgeführt wird das Postprocessing in der Funktion 
\begin{csh} 
private void OnRenderImage(RenderTexture source, RenderTexture destination) 
\end{csh}
Diese Funktion wird von der Unity Engine zur Verfügung gestellt und in einem Skript, das an eine Kamera angehängt ist, immer dann aufgerufen, wenn ein neues Bild gerendert wurde. Source ist dabei das gelieferte Bild und Destination ist das Bild, welches zum Schluss abgebildet wird. Source kann also bevor es nach Destination geschrieben wird noch beliebig verändert werden. Der erste Effekt, welcher auf das Bild angewendet wird, ist Bloom. Bloom ist als Compute Shader verfasst, für den Texturen, in die geschrieben werden soll, das Flag 'enableRandomWrite' benötigen. Dieses lässt sich für einmal erstellte Texturen im Nachhinein nicht mehr ändern und ist in Source standardmäßig deaktiviert. Also ist der erste Schritt, mit der Funktion 
\begin{csh}
Graphics.Blit(source, sourceTex);
\end{csh}
 den Inhalt von Source in die zuvor angelegte Textur sourceTex zu schreiben, für welche das benötigte Flag gesetzt ist.

%image source to source tex

Nun kann der Bloom-Effekt angewandt werden. Zuerst werden mithilfe des Bloomshaders alle hellen Stellen aus sourceTex nach brightTex geschrieben. Der Inhalt von brightTex wird nun verschwommen gemacht, wozu die Textur blurrBuff benötigt wird. Anschlie{\ss}end wird das verschwommene Resultat (brightTex) additiv zurück nach sourceTex geschrieben.

%image bloom

Als nächstes wird Chromatic Aberration auf das fertige Bild mit Bloom (sourceTex) angewandt. Es wird keine zusätzliche Textur benötigt und das Resultat befindet sich in caResult.

%image ca

Nun ist Lens Flare an der Reihe. Als ausgangstextur dient ebenfalls sourceTex und ähnlich wie bei Bloom werden bestimmte Features des Ursprungsbildes in eine separate Textur (lfResult) geschrieben. Diese wird dann wiederum mithilfe von blurrBuff verschwommen gemacht und dieses mal additiv auf caResult zurückgeschrieben. 

%image lf

Vorher jedoch wird das Ergebnis mit der Textur lensDirt kombiniert, die zum Start des Programms einmal aus den beiden Texturen lensDirtTex und starburstTex erstellt wird.

%image lensDirt

Die Effekte Vignette, Scanlines und Displaykrümmung können zuletzt alle mit einmal auf caResult angewendet werden, wobei das Ergebnis direkt nach destination (Argument von OnRenderImage) geschrieben wird.

%image crt

Somit hat das resultierende Bild alle gewünschten Effekte



\subsection{Blur}

Der Blur-Shader ist ein Fragment Shader und wendet einen einfachen Gau{\ss}-schen Weichzeichnungsalgorithmus auf eine Textur an. Benötigt wird ein Ursprungsbild und ein Puffer der selben Grö{\ss}e.



\subsection{Bloom}

\lipsum[3]



\subsection{Chromatic Aberration}

\lipsum[3]



\subsection{Lens Flare}

\lipsum[3]



\subsection{Vignette, warped Display und Scanlines}

\lipsum[3]
