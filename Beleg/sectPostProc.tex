
\section{Postprocessing}

Postprocessing bezeichnet im Kontext der Videospielgrafik die Nachbearbeitung eines bereits ganz oder teilweise gerenderten Bildes mit einem oder mehreren Bildeffekten. Das Ziel des Postprocessings bei Cubix ist es, alte Videoaufnahme- und -wiedergabegeräte nachzubilden. Um diesen Effekt zu erzielen, werden Bildartefakte, die durch diese Hardware entstehen, als Nachbearbeitungseffekte dem fertigen Bild hinzugefügt.

Die verwendeten Effekte, die von alten Kameras verursacht werden, sind Bloom, Lens Flare, Chromatic Aberration und Vignette. 
Ein alter Monitor kann Scanlines verursachen, gewölbt sein und ebenfalls für Vignette und Chromatic Aberration sorgen.

Jeder der genannten Effekte wird in den späteren Abschnitten genauer erläutert. Man beachte, dass sowohl alte Displays als auch Linsen Vignette und Chromatic Aberration verursachen können, was dann zu kleinen Unterschieden im Auftreten führen kann. Die Entscheidung, wie diese Effekte letztendlich darzustellen sind, ist rein artistisch.



\subsection{Postprocessing - Pipeline}

Das Postprocessing wird über ein ebenso benanntes Skript gesteuert. Bloom und Lens Flare werden von einem jeweils eigenen Compute Shader durchgeführt, alle anderen Effekte werden in eigenen Passes eines Image Effect Shaders durchgeführt. Diese sind im Skript als Objekte angelegt:

\begin{csh}
    public ComputeShader bloom;
    public ComputeShader lensFlare;
    public Material postProcMat;
\end{csh}

Weiterhin werden für den Lens Flare eine Textur einer schmutzigen Linse und eine Starburst Textur benötigt:

\begin{csh}
    public Texture2D lensDirtTex;
    public Texture2D starburstTex;
\end{csh}

Zur Sequenziellen Ausführung aller Effekte werden insgesamt 6 RenderTextures angelegt:

\begin{csh}
    public RenderTexture sourceTex;
    public RenderTexture brightTex;
    public RenderTexture blurBuff;
    public RenderTexture caResult;
    public RenderTexture lfResult;
    public RenderTexture lensTex;
\end{csh}

Zum Start des Programms oder falls die Fenstergrö{\ss}e geändert wird, müssen alle diese RenderTextures nmit der Funktion createTexture() neu angelegt werden.

Durchgeführt wird das Postprocessing in der Funktion 
\begin{csh} 
private void OnRenderImage(RenderTexture source, RenderTexture destination) 
\end{csh}
Diese Funktion wird von der Unity Engine zur Verfügung gestellt und in einem Skript, das an eine Kamera angehängt ist, immer dann aufgerufen, wenn ein neues Bild gerendert wurde. Source ist dabei das gelieferte Bild und Destination ist das Bild, welches zum Schluss abgebildet wird. Source kann also bevor es nach Destination geschrieben wird noch beliebig verändert werden. Der erste Effekt, welcher auf das Bild angewendet wird, ist Bloom. Bloom ist als Compute Shader verfasst, für den Texturen, in die geschrieben werden soll, das Flag 'enableRandomWrite' benötigen. Dieses lässt sich für einmal erstellte Texturen im Nachhinein nicht mehr ändern und ist in Source standardmäßig deaktiviert. Also ist der erste Schritt, mit der Funktion 
\begin{csh}
Graphics.Blit(source, sourceTex);
\end{csh}
 den Inhalt von Source in die zuvor angelegte Textur sourceTex zu schreiben, für welche das benötigte Flag gesetzt ist.

%image source to source tex

Nun kann der Bloom-Effekt angewandt werden. Zuerst werden mithilfe des Bloomshaders alle hellen Stellen aus sourceTex nach brightTex geschrieben. Der Inhalt von brightTex wird nun verschwommen gemacht, wozu die Textur blurBuff benötigt wird. Anschlie{\ss}end wird das verschwommene Resultat (brightTex) additiv zurück nach sourceTex geschrieben.

%image bloom

Als nächstes wird Chromatic Aberration auf das fertige Bild mit Bloom (sourceTex) angewandt. Es wird keine zusätzliche Textur benötigt und das Resultat befindet sich in caResult.

%image ca

Nun ist Lens Flare an der Reihe. Als ausgangstextur dient ebenfalls sourceTex und ähnlich wie bei Bloom werden bestimmte Features des Ursprungsbildes in eine separate Textur (lfResult) geschrieben. Diese wird dann wiederum mithilfe von blurBuff verschwommen gemacht und dieses mal additiv auf caResult zurückgeschrieben. 

%image lf

Vorher jedoch wird das Ergebnis mit der Textur lensTex kombiniert, die zum Start des Programms einmal aus den beiden Texturen lensDirtTex und starburstTex erstellt wird.

%image lensTex

Die Effekte Vignette, Scanlines und Displaykrümmung können zuletzt alle mit einmal auf caResult angewendet werden, wobei das Ergebnis direkt nach destination (Argument von OnRenderImage) geschrieben wird.

%image crt

Somit hat das resultierende Bild alle gewünschten Effekte

%complete pipeline



\subsection{Blur}

Für die Effekte Bloom und Lens Flare wird eine Methode benötigt, Texturen verschwommen zu machen, was die Aufgabe der Blur-Shaders ist.
Er ist ein Fragment Shader und wendet einen einfachen Gau{\ss}-schen Weichzeichnungsalgorithmus auf eine Textur an. Benötigt wird ein Ursprungsbild und ein Puffer der selben Grö{\ss}e.

Übergebene Variablen:
\begin{description}
\item[sampler2D MainTex] Die Eingabetextur
\item[float4 MainTexTexelSize] Die Pixelgröße der Textur in x- und y-Richtung
\item[int horizontal] Angabe, ob horizontal oder vertikal verwaschen werden soll
\end{description}

Der Algorithmus funktioniert, indem er zu einem Pixel immer auch den Wert jedes Pixels in der näheren Umgebung abfragt. Alle Werte werden dann mit unterschiedlichen Gewichtungen zusammenaddiert (je weiter vom Ursprungspixel entfernt, desto weniger Einfluss) und ergeben ein verschwommenes Abbild des Originals. Mit einer Distanz von vier Pixeln in jede Richtung würden die abgefragten Pixel wie folgt gewichtet werden:

\includegraphics[height=100pt]{gauss_normal.png}

Diese Methode hat jedoch den Nachteil, dass 81 (9x9) Texturzugriffe für jedes Pixel notwendig sind, was nicht sehr effizient ist.
Die Texturzugriffe lassen sich jedoch verringern, indem in zwei Durchläufen des Shaders die Pixeldaten zuerst nur in horizontale Richtung und dann nur in vertikale Richtung abgefragt wird:

\includegraphics[height=100pt]{gauss_horizontal.png}
\includegraphics[height=100pt]{gauss_vertical.png}

Das Resultat ist dabei fast identisch: 

\includegraphics[height=100pt]{gauss_twopass.png}

Diese Methode nennt sich two-pass Gaussian blur und es sind hier nur 18 (2x9) Texturzugriffe notwendig. Die angelegte Variable 'horizontal' gibt bei jedem Aufruf des Shaders an, ob in die horizontale oder die vertikale Richtung verwaschen werden soll, und wird nach jedem Aufruf invertiert. Zusätzlich ist nun ein separater Puffer vonnöten (hier blurBuff), in dem das resultat des ersten Durchlaufes (horizontal) zwischengespeichert wird und dessen Inhalt im zweiten Durchlauf (vertikal) verschwommen wieder zurück in die ursprüngliche Textur geschrieben wird. Dieser Prozess ist im Postprocessing-Skript in eine eigene Methode blur ausgelagert worden:

\begin{csh}
    private void blur(RenderTexture tex, int count)
    {
        for (int i = 0; i < count; i++)
        {
            postProcMat.SetInt("_horizontal", 1);
            Graphics.Blit(tex, blurBuff, postProcMat, BlurPass);
            postProcMat.SetInt("_horizontal", 0);
            Graphics.Blit(blurBuff, tex, postProcMat, BlurPass);
        }
    }
\end{csh}

Zusätzlich zur zu bearbeitenden Textur wird der Methode eine Variable 'count' übergeben, über welche die Stärke der Verwaschung reguliert werden kann. Dazu wird die Shadersequenz so oft durchlaufen, wie count angibt. Nach jedem Shaderaufruf wird die Uniform Variable 'horizontal' auf den entsprechenden Wert neu gesetzt.

Jedoch lässt sich die Anzahl der Texturzugriffe noch weiter senken. In einem Fragment Shader kann nicht nur auf diskrete Texturkoordinaten zugegriffen werden. Fragt man den Farbwert einer Textur an einer Stelle zwischen zwei Pixeln ab, so werden deren Farben linear interpoliert. In diesem Fall ermöglicht dies, das gleiche Resultat mit nur 10 (2x5) Texturzugriffen zu erzielen. Dazu werden zwei Wertelisten angelegt:
\begin{hlsl}
    static const float weight[3] = { 0.2270270270, 0.3162162162, 0.0702702703 };
    static const float offset[3] = { 0.0, 1.3846153846, 3.2307692308 };
\end{hlsl}
'Offset' gibt an, wie viele Pixel entfernt vom Hauptpixel die Farbdaten bestimmt werden sollen. Zu beachten ist hier, dass keine ganzzaligen Pixelabstände gewählt wurden, um den gewünschten Effekt zu erzielen.
'Weight' gibt zu jedem Offset an, wie stark dieser Wert in das Endergebnis einflie{\ss}t. Mit der richtigen Werteliste ist das Ergebnis identisch zu einem Algorithmus, der mit den 5 ganzzahligen Pixeloffsets 0, 1, 2, 3 und 4 arbeitet, benötigt jedoch nur reichlich die Hälfte der Texturzugriffe.

%https://john-chapman.github.io/2017/11/05/pseudo-lens-flare.html
%http://john-chapman-graphics.blogspot.com/2013/02/pseudo-lens-flare.html
%rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/
%https://learnopengl.com/Advanced-Lighting/Bloom



\subsection{Bloom}

Bloom (Überstrahlung) bezeichnet das Phänomen, dass sehr helle Bereiche eines Bildes nahe Bereiche 'überstrahlen'. Dies resultierte bei alten Kameras daraus, dass sie nicht den gesamten Helligkeitsbereich richtig aufnehmen konnten. In Videospielen und der Filmindustrie wird dieser Effekt gern verwendet, um den Eindruck von gro{\ss}er Helligkeit zu vermitteln, jedoch sollte er auch nicht zu stark sein und ablenken.
Der Algorithmus ist als Compute Shader verfasst und besteht aus zwei Schritten, die von einem jeweils eigenen Kernel ausgeführt werden. 

Übergebene Variablen:
\begin{description}
\item[RWTexture2D<float4> Source] Bildquelle
\item[RWTexture2D<float4> BrightSpots] Textur, in die Helle Stellen geschrieben werden
\item[uniform float threshold] Schwellenwert für die Helligkeit eines Pixels
\end{description}

Den ersten Schritt übernimmt das Kernel 'CSExtractBright'. Hier werden alle Pixel von Source mit der Formel $dot(float3(0.2126, 0.7152, 0.0722), Source[id.xy].rgb) > threshold$ auf ihre Helligkeit geprüft. Da unterschiedliche Lichtfarben für die menschliche Wahrnehmung unterschiedlich zur Helligkeit eines Pixels beitragen, werden die Rot-, Grün- und Blaukanäle des ursprünglichen Bildes unterschiedlich gewichtet (mit den Werten 0.2126, 0.7152 und 0.0722). Ist der Schwellenwert erreicht, werden die Pixeldaten unverändert in BrightSpots geschrieben (BrightSpots[id.xy] = Source[id.xy]), anderenfalls wird in BrigthSpots an dieser Stelle schwarz eingefügt: BrightSpots[id.xy] = float4(0, 0, 0, 1).
Somit erhält man in BrightSpots ein Abbild aller hellen Stellen eines Bildes:

\captionsetup{type=figure}
\includegraphics[height=100pt]{bloom_source.png}
\includegraphics[height=100pt]{bloom_bright.png}
\captionof{figure}{Links: Source, Rechts: BrightSpots}

Anschlie{\ss}end wird der Blur-Effekt auf BrightSpots angewendet, wodurch die hellen Stellen an den Rändern mit den Dunklen verwaschen werden. Im zweiten Schritt wird dann das verschwommene Resultat in BrightSpots vom zweiten Kernel 'CSWriteBack' additiv zurück auf das Ursprungsbild geschrieben. Dadurch wird hellen Objekten ein leichter 'Schein' auf die nahe Umgebung verliehen:

\captionsetup{type=figure}
\includegraphics[height=75pt]{bloom_off.png}
\includegraphics[height=75pt]{bloom_on.png}
\captionof{figure}{Links: Bloom aus, Rechts: Bloom an}




\subsection{Chromatic Aberration}

Chromatic Aberration ist ein von alten Kameralinsen und Röhrenmonitoren verursachtes Bildartefakt, das im Falle der Kameralinse dadurch auftritt, dass das eintreffende Licht von dieser nicht korrekt gebündelt wird. Licht unterschiedlicher Wellenlängen wird unterschiedlich stark von der Linse gebrochen, wodurch besonders kurz- oder langwellige Lichtfarben (zum Beispiel rot und blau) mit einiger Abweichung auf dem Sensor eintreffen. Normalerweise tritt Chromatic Aberration in Richtung der Ränder des Bildes stärker auf, jedoch erschwerte eine zu gro{\ss}e Effektstärke die Leserlichkeit des GUI. In der Mitte des Bildschirmes sollte der Effekt wiederum nicht zu schwach sein, da er bei der wei{\ss}en Spielfigur am besten zur Geltung kam. Deshalt fiel die Entscheidung, die Stärke der Chromatic Aberration für den gesamten Bildschirm auf einen einheitlichen Wert zu setzen.

Als Shader kann der Effekt dadurch nachgebildet werden, dass vom ursprünglichen Bild der rote und blaue Farbkanal mit einer kleinen Abweichung zur eigentlichen Pixelposition abgefragt werden und dann gemeinsam mit dem Grünkanal an der richtigen Position das neue Pixel bilden. Die Abweichung der Position erfolgt für rot und blau in jeweils entgegengesetzte Richtung in einem Fragment Shader:

Übergebene Variablen:
\begin{description}
\item[sampler2D MainTex] Die Eingabetextur
\item[float CAAmount] Abweichung für Zugriffe auf den Rot- und Blaukanal
\end{description}

\begin{hlsl}
    fixed4 col = fixed4(0, 0, 0, 1);
    col.r = tex2D(_MainTex, i.uv + float2(_CAAmount, 0)).r;
    col.g = tex2D(_MainTex, i.uv).g;
    col.b = tex2D(_MainTex, i.uv - float2(_CAAmount, 0)).b;
\end{hlsl}

Wie zu sehen ist, wird der Rotkanal der resultierenden Farbe in MainTex an der entsprechenden Texturpixelposition (i.uv) plus einer Abweichung 'CAAmount' ermittelt. Für den Blaukanal wird i.uv minus CAAmount abgefragt, beim Grünkanal gibt es keine Abweichung. Damit CAAmount als Abweichung nur die x-Position des Pixels beeinflusst, wird ein float2 erstellt, der CAAmount als x-Wert und 0 als y-Wert besitzt, welcher dann zu i.uv (auch zweidimensional) dazuaddiert beziehungsweise davon abgezogen werden kann.
CAAmount kann vom Hauptporgramm aus gesteuert werden, als Standard wurde der Wert 0.0005 gewählt. Das bedeutet, dass rot und blau um ein halbes Tausendstel der Displaybreite (ein paar Pixel) von ihrer ursprünglichen Position abweichen. So sehen verschiedene Werte für CAAmount im Vergleich aus:

\captionsetup{type=figure}
\includegraphics[height=75pt]{bloom_on.png}
\includegraphics[height=75pt]{ca_0005.png}
\includegraphics[height=75pt]{ca_005.png}
\captionof{figure}{Links: kein Effekt, Mitte: CAAmount = 0.0005, Rechts: CAAmount = 0.005}

Chromatic Aberration eignet sich sich bei gro{\ss}en Abweichungswerten auch gut, um das Gefühl von Fehlern beziehungsweise Glitches zu vermitteln. So wird zum Beispiel für kurze Zeit nachdem der Spieler getroffen wurde die Abweichung auf zufällig wechselnde, hohe Werte gesetzt, was den erlittenen Schaden gut verdeutlicht.



\subsection{Lens Flare}

\lipsum[3]



\subsection{Vignette, warped Display und Scanlines}

\lipsum[3]
