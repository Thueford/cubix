\section{Partikelsystem}

Ein Partikelsystem ist im Bereich der Computersimulation die Simulation einer Ansammlung gleichartiger Teilchen, deren Verhalten durch Zufälligkeit variiert werden kann. Partikelsysteme erlauben durch die Auslagerung der Berechnungen auf die Grafikeinheit eines PCs die flüssige Simulation einer gro{\ss}en Menge an Teilchen auf einmal (auf einer NVidia 1070Ti bis zu 10 Mio. Partikel mit 60fps in dieser Implementierung). Diese werden zumeist für die Simulation von Feuer, Rauch, Flüsigkeiten, Explosionen und ähnlich komplexen physikalischen Vorgängen verwendet.

In Cubix werden Partikelsysteme an verschiedensten Stellen eingesetzt, um die Optik aufzuwerten und das visuelle Feedback von Explosionen und Treffern zu verstärken. Zudem werden Partikel für Portale, für Bewegungsspuren, Ressourcen und für Explosionen eingesetzt.



\subsection{Implementierung}

Das Partikelsystem wurde zunächst auf Basis eines Artikels über das Zeichnen von \sq{tausenden Meshes auf einmal}\cite{qPartS1} in Unity basierend auf der Render-Funktion \href{https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstancedIndirect.html}{DrawMeshInstancedIndirect} konstruiert.

Für die gesteuerte Emission von Partikeln wurde später ein GitHub-Repository eines ebenfalls selbst implementierten Partikelsystems\cite{qPartS2} zu Rate gezogen. Die wesentliche Neuerung war die etwas einfacher zu verwendende Render-Funktion \href{https://docs.unity3d.com/ScriptReference/Graphics.DrawProceduralNow.html}{DrawProceduralNow} und das Benutzen von Gradient-Texturen zur Farbänderung.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{partInspect.png}
\caption{Ansicht im Unity-Inspektor}
\label{img:partInspect}
\end{figure}


\subsection{Aufbau}

Das Partikelsystem besteht aus einer Controller-Klasse in CSharp, welche sämtliche Einstellungen für das Partikelsystem dem Objektinspektor bereitstellt\#, einem Compute-Shader welcher Kernel für das Initialisieren, Emittieren und Aktualisieren von Partikeln besitzt sowie einem Unlit-Shader für die Darstellung der Partikel inklusive Billboard.


\subsection{Partikel-Struktur}

Um den aktuellen Status eines einzelnen Partikels zu repräsentieren sollten möglichst kompakt alle für die individuelle Bewegung und Darstellung notwendigen Daten gespeichert werden. Dazu gehören die aktuelle Position, Geschwindigkeit und einwirkende Kraft, die Farbe und grö{\ss}e des Partikels und ein Random-Seed wert, der ggf. für zufälliges Verhalten verwendet wird.

\begin{csh}[caption=Partikelstruktur,label=lst:particle]
public struct Particle
{
    public Vector3 pos, vel, force;
    public Vector4 col, size; // xy: size,  z: age, w: maxage
    public float seed;
}
\end{csh}


\subsection{Partikel-Verhalten}

Darüber hinaus gibt es Variablen, die für jedes Partikel im Partikelsystem gleich gelten. Diese bestimmen, wie genau sich Partikel verhalten. Dazu gehören Ausgangswerte aller Positionsbezogenen Daten (Spawnposition und Geschwindigkeit), Grö{\ss}e, Farbe und Lebensdauer und wie sie sich über letztere hinweg verändern.

\begin{csh}
public class Particles : MonoBehaviour
{
    public Stats stats;                   // ps statistics for inspector
    public GeneralProps properties;       // general ps properties
    public RenderSettings renderSettings; // render settings (alpha blending)

    public DynamicEffect pos, vel, force, posFac; // dynamic mechanic effects
    public Colors color;          // Color [with variation & gradient]
    public Capsule<Vector3> size; // xy: offset, z: timefac
    public Vector4 attractor;     // Vector3 + w: factor
    /* ... */
}
\end{csh}



\subsubsection{Positionsdaten}

Für Positionsdaten wird eine allgemeine Struktur mit standardisierter Uniform-Benennung verwendet, die einen Ausgangsvektor, einen Abweichungsvektor und eine Form in der diese Abweichung auftritt, definiert.

\begin{csh}[caption=DynamicEffect Struktur]
public enum Shape { DOT, CIRCLE, RECT, SPHERE, CUBE };
public struct DynamicEffect
{
    public Vector3 offset, scale;
    public Shape shape;
}
\end{csh}



\subsubsection{Farbdaten}

Farbdaten werden entweder absolut oder als Gradient angegeben. Dabei kann optional Variation durch zufällige Interpolation zwischenden Farbwerten erreicht werden. Die Gradiente werden als dynamisch generierte Textur an den Shader gereicht, die absoluten Farbwerte als einfache Uniforms.

\begin{csh}[caption=Generierung der Gradient-Textur]
int height = useVariation ? 2 : 1;
tex = new Texture2D(steps, height);
for (int i = 0; i < steps; i++)
{
    tex.SetPixel(i, 0, gradient.Evaluate(i / (float)steps));
    if (useVariation) tex.SetPixel(i, 1, gradient2.Evaluate(i / (float)steps));
}
tex.Apply();
\end{csh}



\subsection{Partikelsystem Eigenschaften}

Zu guter Letzt hat ein Partikelsystem noch einige globale Eigenschaften, die deren Verhalten definieren. Dazu gehört die maximale Partikelzahl, die Emmitierrate, die Lebensdauer eines Partikels, sowie ob das PS aktiv ist, ob es sich wiederholt (d.h. ständig generiert wird oder nur bis insgesamt die maximale Partikelzahl erreicht wurde), ob es vorwärmen (d.h. einen Lebenszyklus beim Initialisieren emulieren soll) und einige weniger Relevante Eigenschaften auf die ich ggf. später zurückkomme.

\begin{csh}[caption=Partikel Struktur]
public struct GeneralProps
{
    public bool enabled, repeat, prewarm;
    public PerformanceMode performance;
    public int maxParts;
    public float startDelay, emissionRate, lifetime;
}
\end{csh}



\subsection{Berechnung}


\subsubsection{Setup}

Um die Partikel möglichst effizient berechnen zu können werden Compute Shader verwendet. Alle Daten die an den ComputeShader gegeben werden sollen werden in sog. ComputeBuffer geschrieben. Diese werden direkt auf der Grafikkarte abgelegt. Das sind zum einen sämtliche Partikeldaten als Standard StructuredBuffer und ein AppendBuffer von IDs toter Partikel.

\begin{csh}[caption=Controller Setup,label=lst:partSetup]
// Calculation
[NotNull] public ComputeShader compute;
private ComputeBuffer particlesBuf, deadBuf, counterBuf;

// Display
private ComputeBuffer quadVertBuf;
public RenderSettings renderSettings = RenderSettings.Default;
[NotNull] public Texture tex;  // particle texture
[NotNull] public Material mat; // UnlitShader rendering material
\end{csh}

Der ComputeShader beinhaltet an dem Punkt nur die Deklarationen der Compute-Kernel und der Partikelstruktur (siehe \fullref{lst:particle}), sowie einer Variable für den Partikel-Buffer.

\begin{hlsl}[caption=Compute Setup]
#pragma kernel Init
#pragma kernel Emit
#pragma kernel Update
#include "./Particle.cginc"
RWStructuredBuffer<Particle> _Particles;
\end{hlsl}

\subsubsection{Initialisierung}

Bei der Initialisierung werden im Init-Kernel sämtliche Partikel IDs dem deadBuffer hinzugefügt und deren Lebenszeit auf 0 gesetzt. Das ist der Ausgangszustand, bei dem es keine lebendingen Partikel gibt.

\subsubsection{Emission}

Um Partikel zu emmittieren wird in zu jedem Frame-Update geprüft, wie viele Partikel abhängig von der Spawn- und der Framerate gespawnt werden sollen. Um auch sehr niedrige Raten zu unterstützen wird eine Partikelzeit mitgezählt, die jedes Frame um die Frametime erhöht, und bei jedem Emit um die Emissiontime gesenkt wird. So kann bspw. auch bei einer Bildrate von 60fps ein einzelnes Partikel pro Sekunde emmittiert werden, da die Zeit zwischen zwei Frames bei dem kein Partikel emmittiert wird nicht verloren geht.

\begin{csh}[caption=Controller Emission]
if (properties.enabled && properties.emissionRate > 1e-2)
{
    partTimer += Time.deltaTime;
    int emitted = DispatchEmit((int)(partTimer * properties.emissionRate));
    partTimer -= emitted / properties.emissionRate;
}
\end{csh}

Bevor die Partikel tatsächlich gespawnt werden wird noch die Anzahl gegen verschiedene Grenzen getestet - ua. die maximal lebendige Partikelzahl und bei nichtwiederholendem PS die bisher insgesamt emmittierte Partikelzahl.

Dann werden dem Compute-Shader sämtliche für den Spawn relevanten Informationen per Uniform überreicht. Ua. wie beim Init-Kernel die Partikeldaten und die IDs toter Partikel - diesmal aber als Comsume- statt AppendBuffer, da wiederbelebten Partikel nicht tot sind und somit aus dem deadBuffer entfernt werden müssen. Weiterhin werden einige Flags als Bitmaske in einem Integer übergeben, um ggf. den Datenverkehr gering zu halten, sowie eine Reihe an Zufallswerten für die Randomisierung einiger Werte.

\begin{csh}[caption=Controller Emission Dispatch]
// calculate actually possible emission count
count = Mathf.Min(count, 1 << 15, curMaxParts - stats.alive);
if (!properties.repeat && stats.emitted + count > curMaxParts)
    count = curMaxParts - stats.emitted;

UniformEmit(kernelEmit);
compute.Dispatch(kernelEmit, count, 1, 1);
\end{csh}

Im Shader werden nun Partikel aus dem DeadBuffer entnommen und diese mit Eigenschaften eines Lebendingen Partikels initialisiert. Um eine zufällige Streuung von Vektoren ua. für die Positionsdaten zu erreichen, wurde eine Funktion definiert, die aus drei Eingabewerten mittels einer stark schwankenden Funktion einen neuen, möglichst zufälligen Wert generiert. Damit kann durch Umordnung der vier einmalig im Hauptprogramm berechneten Seedwerte, kombiniert mit der Partikel-ID eine Vielzahl an Pseudozufallswerten generiert und das Verhalten der Partikel individualisiert werden.

Um die Partikel in einem bestimmten Bereich spawnen zu lassen werden Scales verwendet, zwischen dem die resultierenden Vektoren schwanken können. Um noch etwas mehr Variabilität zu sorgen kann man die Vektoren mittels einer Shape-ID 'formen'. Derzeit werden ausschlie{\ss}lich DOT (formlos) CIRCLE, RECT (2D), SPHERE und CUBE (3D) unterstützt. Die Dimensionsunterscheidung muss unternommen werden um die Vektoren nicht auf einer Achse zu verteilen, die garnicht verwendet wird und dann dort gehäuft auftreten.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{partShapes.png}
\caption{Spawhshapes}
\label{img:partShapes}
\end{figure}

In folgendem Listing wurde noch beispielhaft die Berechnung der Spawnposition gezeigt, die von Geschwindigkeit und Beschleunigung erfolgt analog, wenn auch aus Intuitivitätsgründen nicht 100\% identisch.

\begin{hlsl}[caption=Compute Emit Kernel]
uint id = _Alive.Consume(); // pop dead particle to alive
Particle p = _Particles[id];

p.size.xy = float4(_Size, _Lifetime);
p.rand = rand(_Seeds.wzy);
p.color = F(P_CLRVARY) ? lerp(_Color, _Color2, p.rand) : _Color;

// position
float3 d = float3(ran(_Seeds.xzy), ran(_Seeds.yxz), ran(_Seeds.zyx));
d = getShaped(d, _PosShape);
p.pos = d * (_PosOffset + _PosScale * rand(_Seeds.wxy));
/* ... */
\end{hlsl}


\subsubsection{Update}

Bei jedem Frame-Update wird der Status jedes Partikels aktualisiert. Dazu werden nur noch die Daten benötigt, die das Partikel während seiner Lebensspanne von au{\ss}en verändern. Dazu gehört in jedem Fall die Zeitdifferenz zum letzten Update, die Statusflags, der Farbgradient falls verwendet, sowie die Grö{\ss}enänderung, da diese bisher für alle Partikel gleich ist. Des weiteren kann man ein Objekt definieren, zu dessem Position das Partikel konstant hingezogen werden soll. Das wurde ua. für den Ressourcenpartikeleffekt benötigt.

\begin{csh}[caption=Controller Update]
DispatchUpdate();
if (properties.performance > PerformanceMode.LOW)
{
    _alive -= Time.deltaTime * Mathf.Ceil(stats.alive) / properties.lifetime;
    stats.alive = Mathf.CeilToInt(_alive);
    stats.dead = curMaxParts - stats.alive;
}
\end{csh}

Im Shader werden sämtliche Änderungen an einem Partikel abhängig von der Zeitdifferenz vorgenommen. Erreicht es hierbei ein Alter grö{\ss}er als die Lebensdauer, wird es wieder als tot markiert und dem DeadBuffer hinzugefügt. Bereits tote Partikel werden übersprungen, es wird aber dennoch für jedes Partikel die Update-Funktion aufgerufen, da der Shader das nicht im vorhinein bestimmen kann. Die Farbe wird ggf. aus der Gradienttextur gesampled und interpoliert.

\begin{hlsl}[caption=Compute Update]
float4 getLifeColor(float2 life, float seed);
/* ... */

if (p.size.w == 0) return; // skip dead
if (p.size.z < _DeltaTime) /* make dead */;

float3 magnet = _Attractor.w * normalize(_Attractor.xyz - p.pos);

p.size.z -= _DeltaTime;             // aging
p.size.xy += _SizeVel * _DeltaTime; // growth
p.vel += p.force * _DeltaTime;      // acceleration
p.pos += (p.vel + magnet) * _DeltaTime; // movement
if (F(P_CLRGRAD)) p.color = getLifeColor(p.size.zw, p.rand);
\end{hlsl}

Der Update-Kernel hat hierbei eine zusätzliche Funktion zum Vorwärmen das Partikelsystems. Beim Vorwärmen eines Partikelsystems werden beim Zurücksetzen zunächst so viele Partikel emmittiert, wie in einem Lebenszyklus durchschnittlich leben würden. Dann berechnet der Shader für jedes lebendige Partikel ein zufälliges Alter und führt so oft die Update-Funktion mit der eingestellten Deltatime auf, bis dieses erreicht ist.

\begin{hlsl}[caption=Compute Prewarm Update Kernel]
Particle p = _Particles[id.x];
float age = p.size.w * p.rand - _DeltaTime;
for (float i = 0; i < age; i += _DeltaTime) DoUpdate(id);
\end{hlsl}

Nach jedem Update wird anhand der durchschnittlichen Sterbenderate $r_{mort} = n_{alive} / t_{alive}$ berechnet, wie viele Partikel aktuell am leben sind. Das ist erheblich effizienter im Vergleich zu einer vorherigen Version, in der ein separater CounterBuffer dazu verwendet wurde, die genaue Grö{\ss}e des deadBuffers auszulesen. Da dieser physisch nur auf der Grafikkkarte existiert scheint Unity dazu eine Funktion namens Gfx.GetComputeBufferData\_Request zu benutzen, die zur Synchronisation eine Semaphore benutzt, was schon bei wenigen Partikelsystemen erhebliche Performanceeinbu{\ss}en mit sich brachte.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\linewidth]{partBufCount.png}
\includegraphics[width=0.95\linewidth]{partDataReq.png}
\caption{ReadDeadCount im Unity Profiler}
%\label{img:partBufCount}
\end{figure}
    

\subsection{Darstellung}

Das Rendern der Partikel erfolgt über einen Unlit-Shader. Das Grundgerüst besteht aus einer Shader-Deklaration mit allen vom Inspektor übergebenen Eigenschaften, ua. die Rendertextur und BlendModes, die für korrektes Alpha-Blending nach Bedarf eingestellt werden können. Die BlendModes werden in der Struktur RenderSettings hinterlegt, zusammen mit einigen voreingestellten Modi\footnote{nach Artikel \href{https://elringus.me/blend-modes-in-unity}{BlendModes in Unity} vom 12.05.2015, Zugriff 23.06.2021}.

Dem Folgt ein Subshader-Pass der sämtliche Rendereinstellungen vornimmt. Da Partikel transparent sind, wird die Transparent queue zum Rendern verwendet. Es ist au{\ss}erdem wichtig ZWrite auszuschalten, da die Partikel sonst nicht korrekt sortiert werden (siehe \fullref{img:zoff}). Darauf folgt schlie{\ss}lich der tatsächliche Shader-Code des Fragment und des Vertex-Shaders.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\linewidth]{zwrite.png}
\caption{ZWrite links: On, rechts: Off}
\label{img:zoff}
\end{figure}


Die Variablen für das Rendering sind im \fullref{lst:partSetup} bereits enthalten. Erwähnenswert ist der Buffer für Vertexkoordinaten eines Partikels - in diesem Falle die eines Quads, der an den Unlit-Shader für die Berechnung des Billboards gegeben wird.

Das Rendering wird im Controller letztendlich mit der Funktion \href{https://docs.unity3d.com/ScriptReference/Graphics.DrawProceduralNow.html}{DrawProceduralNow} ausgelöst. Dieser bezieht seine Daten aus dem aktuell eingestellten ShaderPass (0), an dem das Shader-Material gebunden wurde. Die Partikeldaten werden somit direkt vom ComputeShader an den UnlitShader weitergereicht.

\begin{csh}[caption=Partikel Rendering]
mat.SetBuffer("_Particles", particlesBuf);
mat.SetBuffer("_QuadVert", quadVertBuf);
renderSettings.Uniform(mat);
mat.SetPass(0);

Graphics.DrawProceduralNow(MeshTopology.Triangles, meshVerts.Length, deadBuf.count);
\end{csh}

Der Vertex Shader berechnet zunächst von lebendigen Partikeln das Billboard - dh. es dreht die Vertices richtung Kamera. Dafür werden die Partikel zunächst durch die Kamera-View Matrix transformiert, dann die Vertex-Positionen addiert und schlie{\ss}lich durch die Projektionsmatrix richtung Kamera gedreht. Die UV-Koordinaten sowie die Farbdaten werden dann an den Fragment-Shader weitergegeben, der die Farbdaten der Textur mit der Partikelfarbe multipliziert.

\begin{hlsl}[caption=Unlit Billboard Vertex Shader]
v2f vert(uint vid : SV_VertexID, uint iid : SV_INSTANCEID)
{
    float3 vpos = float3(p.size.xy * _QuadVert[vid], 0);
    float4 ppos = float4(p.pos, 1);
    o.pos = mul(UNITY_MATRIX_P, float4(vpos, 1) + mul(UNITY_MATRIX_V, ppos));
    /* ... */
}
\end{hlsl}

% \\begin\{.*?\}[\s\S\n]*?\\end\{.*
