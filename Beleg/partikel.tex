
\subsection{Partikel-Struktur}
\label{lst:particle}

Um den aktuellen Status eines einzelnen Partikels zu repräsentieren sollten möglichst kompakt alle für die Bewegung und Darstellung notwendigen Daten gespeichert werden. Dazu gehören die aktuelle Position, Geschwindigkeit und einwirkende Kraft, die Farbe und größe des Partikels und ein Random-Seed wert, der ggf. für zufälliges Verhalten verwendet wird.

\begin{csh}
public struct Particle
{
    public Vector3 pos, vel, force;
    public Vector4 col, size; // xy: size,  z: age, w: maxage
    public float rand;
}
\end{csh}


\subsection{Partikel-Verhalten}

Darüber hinaus gibt es Variablen, die für jedes Partikel im Partikelsystem gleich gelten. Diese bestimmen, wie genau sich Partikel verhalten. Dazu gehören Ausgangswerte aller Positionsbezogenen Daten (Spawnposition und Geschwindigkeit), Größe, Farbe und Lebensdauer und wie sie sich über letztere hinweg verändern.

% \begin{csh}
% public class Particles : MonoBehaviour
% {
%     #region Public Variables
%     [Header("General")]
%     public Stats stats;
%     public GeneralProps properties;
%     public RenderSettings renderSettings;

%     [Header("Particles")]
%     public DynamicEffect pos, vel, force, posFac;
%     public Colors color = Colors.dflt;
%     [Tooltip("xy: offset, z: timefac")]
%     public Capsule<Vector3> size;
%     [Tooltip("Vector3 + w: factor")]
%     public Vector4 attractor;
%     #endregion

%     #region Flags
%     private static int F(bool v, int p) => v ? 1 << p : 0;
%     int GetFlags() =>
%         F(!stats.prewarmed, 0) +
%         F(color.useGradient, 1) +
%         F(color.useVariation, 2);
%     #endregion
%     // ...
%     #endregion
% \end{csh}



\subsubsection{Positionsdaten}

Für Positionsdaten wird eine allgemeine Struktur mit standardisierter Uniform-Benennung verwendet, die einen Ausgangsvektor, einen Abweichungsvektor und eine Form in der diese Abweichung auftritt, definiert.

\begin{csh}
public enum Shape { DOT, CIRCLE, RECT, SPHERE, CUBE };

[System.Serializable]
public struct DynamicEffect
{
    public Vector3 offset, scale;
    public Shape shape;

    public void Uniform(ComputeShader cs, string name)
    {
        cs.SetVector(name + "Offset", offset);
        cs.SetVector(name + "Scale", scale);
        cs.SetInt(name + "Shape", (int)shape);
    }
}
\end{csh}



\subsubsection{Farbdaten}

Farbdaten werden entweder als Absoluter oder als Gradient angegeben. Dabei kann optional Variation durch zufällige Interpolation zwischen zwei Absoluter oder Gradientwerte erreicht werden. Die Gradiente werden als dynamisch generierte Textur an den Shader gereicht, die Absoluten Farbwerte als einfache Uniforms.

\begin{csh}
[System.Serializable]
public struct Colors
{
    public Color color, color2;
    public bool useVariation, useGradient;
    [Range(2, 256)] public int steps;
    public Gradient gradient, gradient2;

    // returns a k x steps Texture of the defined gradient
    // when using color variation, k = 2, otherwise 1
    private Texture2D getTexture();

    // uniform gradient texture to compute kernel (generated by getTexture())
    public void Uniform(ComputeShader compute, int kernel, string name);

    // uniform initial color(s) to compute shader
    public void UniformEmit(ComputeShader compute, string name)
}
\end{csh}



\subsection{Partikelsystem Eigenschaften}

Zu guter Letzt hat ein Partikelsystem noch einige globale Eigenschaften, die dessen Verhalten definieren. Dazu gehört die maximale Partikelzahl, die Emmitierrate, die Lebensdauer eines Partikels, sowie ob das PS aktiv ist, ob es sich wiederholt (d.h. ständig generiert wird oder nur bis insgesamt die maximale Partikelzahl erreicht wurde), ob es vorwärmen (d.h. einen Lebenszyklus beim Initialisieren emulieren soll) und einige weniger Relevante Eigenschaften auf die ich ggf. später zurückkomme.

\begin{csh}
[System.Serializable]
public struct GeneralProps
{
    public bool enabled;
    public bool repeat;
    public bool prewarm;
    public bool destroyOnFinished;
    public PerformanceMode performance;

    public int maxParts;
    public float startDelay, emissionRate, lifetime;
}
\end{csh}



\subsection{Berechnung}


\subsubsection{Setup}

Um die Partikel möglichst effizient berechnen zu können werden Compute Shader verwendet. Alle Daten die an den ComputeShader gegeben werden sollen werden in sog. ComputeBuffer geschrieben. Diese werden direkt auf der Grafikkarte abgelegt. Das sind zum einen sämtliche Partikeldaten als Standard StructuredBuffer und ein AppendBuffer von IDs toter Partikel.

\begin{csh}
#region Variables
[NotNull] public Texture tex;  // particle texture
[NotNull] public Material mat; // UnlitShader rendering material
[NotNull] public ComputeShader compute;

private ComputeBuffer particlesBuf; // particle properties
private ComputeBuffer deadBuf;      // dead particle indices
private ComputeBuffer quadVertBuf;  // particle vertices
#endregion

#region Setup

private void InitializePartBuffer()
{
    particlesBuf = new ComputeBuffer(stats.bufferSize, Marshal.SizeOf<Particle>());

    deadBuf = new ComputeBuffer(stats.bufferSize, sizeof(int), ComputeBufferType.Append);
    deadBuf.SetCounterValue(0);

    counterBuf = new ComputeBuffer(counterArray.Length, sizeof(int), ComputeBufferType.IndirectArguments);
    counterBuf.SetData(counterArray);

    quadVertBuf = new ComputeBuffer(meshVerts.Length, Marshal.SizeOf<Vector2>());
    quadVertBuf.SetData(meshVerts);
}

#endregion
\end{csh}

Der ComputeShader beinhaltet an dem Punkt nur die Kernel-Deklarationen, ein Include einiger Präprozessor-Makros und der obigen Partikel-Struktur (siehe \nameref{lst:particle}), sowie dem Partikel-Buffer. % Diese kommen manchmal doppelt vor, da Unity intern eine Restriktion von $2^16 = 65536$ Threadgruppen pro Kernel vorgibt. Dh. mit einem Aufruf mit mehr als $2^16$ Elementen würde er nicht alle Elemente abarbeiten können, und mit weniger würde die Grafikkarte unnötig ausgelastet.

\begin{hlsl}
#pragma kernel Init
#pragma kernel Emit
#pragma kernel Update

#define THREADS 1024
#include "./Particle.cginc"

RWStructuredBuffer<Particle> _Particles;
\end{hlsl}

\subsubsection{Initialisierung}

Bei der Initialisierung werden

\begin{csh}
private void DispatchInit()
{
    compute.SetBuffer(kernelInit, "_Particles", particlesBuf);
    compute.SetBuffer(kernelInit, "_Dead", deadBuf);
    compute.Dispatch(kernelInit, stats.groupCount, 1, 1);
}
\end{csh}

\begin{hlsl}
ConsumeStructuredBuffer<uint> _Alive;

[numthreads(THREADS, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    _Particles[id.x].size.w = 0;
    _Dead.Append(id.x);
}
\end{hlsl}



\subsubsection{Emit}
\begin{csh}
#region Emit

private void UniformEmit(int kernel)
{
    compute.SetBuffer(kernel, "_Particles", particlesBuf);
    compute.SetBuffer(kernel, "_Alive", deadBuf);

    compute.SetInt("_Flags", GetFlags());
    compute.SetVector("_PosParent", transform.position); // + posOffset
    // compute.SetMatrix("_Rotation", Matrix4x4.Rotate(rotation));
    compute.SetVector("_SpdParent", velocityFactor * _velocity);
    compute.SetVector("_Seeds", new Vector4(Random.value, Random.value, Random.value, Random.value));
    compute.SetFloat("_Lifetime", properties.lifetime);

    pos.Uniform(compute, "_Pos");
    vel.Uniform(compute, "_Spd");
    force.Uniform(compute, "_Force");
    posFac.Uniform(compute, "_PosFac");
    //radial.Uniform(compute, "_Radial");

    compute.SetVector("_Size", size.val);
    color.UniformEmit(compute, "_Color");
}

public int DispatchEmit(int count)
{
    if (!properties.repeat && stats.emitted > curMaxParts) return 0;

    if (stats.medAlive >= curMaxParts && properties.repeat && stats.alive + count > curMaxParts)
        ReadDeadCount(true);
    
    count = Mathf.Min(count, 1 << 15, curMaxParts - stats.alive);
    if (!properties.repeat && stats.emitted + count > curMaxParts)
        count = curMaxParts - stats.emitted;

    if (count <= 0) count = 0;
    stats.ppf = count;
    stats.pps = Mathf.RoundToInt(count / Time.deltaTime);
    if (count <= 0) return 0;

    stats.medAlive = properties.lifetime * properties.emissionRate;
    stats.emitted += count;
    if (properties.performance > PerformanceMode.LOW)
    {
        stats.alive += count;
        _alive += count;
        stats.dead = curMaxParts - count;
    }

    UniformEmit(kernelEmit);
    compute.Dispatch(kernelEmit, count, 1, 1);
    return count;
}
#endregion
\end{csh}

\subsubsection{Update}
\begin{csh}
#region Update
private void UniformUpdate(int kernel)
{
    compute.SetBuffer(kernel, "_Particles", particlesBuf);
    compute.SetBuffer(kernel, "_Dead", deadBuf);
    color.Uniform(compute, kernel, "_Color");

    compute.SetInt("_Flags", GetFlags());
    compute.SetVector("_PosParent", transform.position);
    compute.SetVector("_SpdParent", _velocity * velocityFactor);
    compute.SetVector("_Attractor", attractor);
    compute.SetFloat("_SizeVel", size.val.z);
    compute.SetFloat("_DeltaTime", stats.initialized ? Time.deltaTime : Time.fixedDeltaTime);
}

private void DispatchUpdate()
{
    if (!stats.initialized || particlesBuf == null) Initialize();
    UniformUpdate(kernelUpdate);
    compute.Dispatch(kernelUpdate, stats.groupCount, 1, 1);
    if (properties.performance <= PerformanceMode.MEDIUM)
        ReadDeadCount();
}

private float tLastCount = -1;
private void ReadDeadCount(bool force = false)
{
    if (!(properties.performance == PerformanceMode.LOW ||
        force || Time.time - tLastCount >= deadUpdDelay)) return;
    tLastCount = Time.time;

    ComputeBuffer.CopyCount(deadBuf, counterBuf, 0);
    counterBuf.GetData(counterArray);
    stats.dead = counterArray[0];
    stats.alive = curMaxParts - stats.dead;
    _alive = stats.alive;
}

#endregion
\end{csh}

\subsection{Darstellung}

% ein IndirectArguments-Buffer der Vertexkoordinaten eines Partikels - in diesem Falle die eines Quads.
