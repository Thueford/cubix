#pragma kernel InitOne
#pragma kernel Init
#pragma kernel UpdateOne
#pragma kernel Update
#pragma kernel EmitOne

#define THREADS 1024

#include "./Particle.cginc"

float c : SV_DispatchThreadID;
float rand(float3 o) {
    return frac(sin(dot(o*c, float3(12.9898, 78.233, 45.5432))) * 43758.5453);
}
float ran(float3 o) {
    return 2 * rand(o) - 1;
}


RWStructuredBuffer<Particle> _Particles;
AppendStructuredBuffer<uint> _Dead;
ConsumeStructuredBuffer<uint> _Alive;


int _Flags;
float3 _ParentPosition;
float _SizeVel;
float _DeltaTime;
Texture2D<float4> _ColorGrad;
float _ColorSteps;

#define getAge(life) (1 - life.x / life.y)

float4 getLifeColor(float2 life, float seed)
{
    float4 color, color2;
    color = _ColorGrad.Load(int3(round(_ColorSteps * getAge(life)), 0, 0));
    if (F(P_CLRVARY))
    {
        color2 = _ColorGrad.Load(int3(round(_ColorSteps * getAge(life)), 1, 0));
        color = lerp(color, color2, seed);
    }
    return color;
}

void DoUpdate(uint3 id)
{
    Particle p = _Particles[id.x];
    if (p.size.w == 0) return;
    
    if (p.size.z < _DeltaTime)
    {
        _Dead.Append(id.x);
        _Particles[id.x].size.w = 0;
        return;
    }
    
    p.size.z -= _DeltaTime;
    p.size.xy += _SizeVel * _DeltaTime;
    p.vel += p.force * _DeltaTime;
    p.pos += p.vel * _DeltaTime;
    if (F(P_CLRGRAD)) p.color = getLifeColor(p.size.zw, p.seed);

    _Particles[id.x] = p;
}

[numthreads(1, 1, 1)]
void UpdateOne(uint3 id : SV_DispatchThreadID)
{
    DoUpdate(id);
}

[numthreads(THREADS, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    DoUpdate(id);
}


float4 _Seeds;
float _Lifetime;

float2 _Size;

// float4x4 _Rotation;
float3 _PosParent;
float3 _PosOffset;
float3 _PosScale;

float3 _SpdParent;
float3 _SpdOffset;
float3 _SpdScale;

float3 _ForceOffset;
float3 _ForceScale;

float3 _PosFacOffset;
float3 _PosFacScale;

float4 _Color, _Color2;

float3 sqrNormalize(float3 v) {
    float3 av = abs(v);
    return v / max(max(av.x, av.y), av.z);
}

[numthreads(1, 1, 1)]
void EmitOne()
{
    uint id = _Alive.Consume();
    Particle p = _Particles[id];
    c = id + 1;
    
    p.size.xy = _Size;
    p.size.zw = _Lifetime;
    p.seed = rand(_Seeds.wzy);
    
    float3 d;
    
    // position
    d = float3(ran(_Seeds.xzy), ran(_Seeds.yxz), ran(_Seeds.zyx));
    if (F(P_POSSHP)) d = normalize(PI * sin(d));
    else d = sqrNormalize(d);
    p.pos = d * (_PosOffset + _PosScale * rand(_Seeds.wxy));
    //p.pos = mul(_Rotation, float4(p.pos, 1)).xyz;
    
    // velocity
    d = float3(ran(_Seeds.xyz), ran(_Seeds.yzx), ran(_Seeds.zxy));
    if (F(P_SPDSHP)) d = normalize(PI * sin(d));
    else d = sqrNormalize(d);
    p.vel = _SpdOffset.xyz + _PosFacOffset * p.pos + d * _SpdScale.xyz;
    //p.vel = mul(_Rotation, float4(p.vel, 1)).xyz;
    
    // force
    d = float3(ran(_Seeds.xyw), ran(_Seeds.yzw), ran(_Seeds.zxw));
    if (F(P_FORCESHP)) d = normalize(PI * sin(d));
    else d = sqrNormalize(d);
    p.force = _ForceOffset.xyz + _PosFacScale * p.pos + d * _ForceScale.xyz;
    //p.force = mul(_Rotation, float4(p.force, 1)).xyz;
    
    p.pos += _PosParent;
    p.vel += _SpdParent;
    p.color = F(P_CLRVARY) ? lerp(_Color, _Color2, p.seed) : _Color;
        
    _Particles[id] = p;
}


// limited to 65536 threadgroups
[numthreads(1, 1, 1)]
void InitOne(uint3 id : SV_DispatchThreadID)
{
    _Particles[id.x].size.w = 0;
    _Dead.Append(id.x);
}

[numthreads(THREADS, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    _Particles[id.x].size.w = 0;
    _Dead.Append(id.x);
}