#pragma kernel InitOne
#pragma kernel Init
#pragma kernel UpdateOne
#pragma kernel Update
#pragma kernel EmitOne

#define THREADS 256

#include "./Particle.cginc"

float rand(float3 o) {
    return frac(sin(dot(o, float3(12.9898, 78.233, 45.5432))) * 43758.5453);
}
float ran(float3 o) {
    return 2 * rand(o) - 1;
}


RWStructuredBuffer<Particle> _Particles;
AppendStructuredBuffer<uint> _Dead;
ConsumeStructuredBuffer<uint> _Alive;


float3 _ParentPosition;
float _DeltaTime;

// limited to 65536 threadgroups
[numthreads(1, 1, 1)]
void InitOne(uint3 id : SV_DispatchThreadID)
{
    _Particles[id.x].life = 0;
    _Dead.Append(id.x);
}

[numthreads(THREADS, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    //InitOne(id);
}

void DoUpdate(uint3 id)
{
    Particle p = _Particles[id.x];
    if (p.life.y == 0) return;
    
    if (p.life.x < _DeltaTime)
    {
        _Dead.Append(id.x);
        _Particles[id.x].life.y = 0;
        return;
    }
    
    p.life.x -= _DeltaTime;
    p.pos += p.vel * _DeltaTime;

    _Particles[id.x] = p;
}

[numthreads(1, 1, 1)]
void UpdateOne(uint3 id : SV_DispatchThreadID)
{
    DoUpdate(id);
}

[numthreads(THREADS, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    DoUpdate(id);
}


float4 _Seeds;
float4 _Speed;
float _Lifetime;
float _Range;
float4 _Color;

[numthreads(1, 1, 1)]
void EmitOne()
{
    uint id = _Alive.Consume(), c = id;
    Particle p = _Particles[id];
    if (c == 0) c = 0.5;
    
    p.life = _Lifetime;
    float3 dir = float3(ran(_Seeds.xzy * c), ran(_Seeds.yxz * c), ran(_Seeds.zyx * c));
    dir = normalize(dir);
    
    p.vel = _Speed.xyz * dir;
    p.pos = _Range * pow(rand(_Seeds.xyz * c), 0.2) * normalize(dir);
    
    p.color = lerp(_Color, 1, rand(_Seeds.xxz * c));
    p.color.a = _Color.a;
    
    _Particles[id] = p;
}